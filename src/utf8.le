global pub;

struct rune {
    i32 inner;
};

fn rune::__fmt__(rune self, i32 nesting) {
    return self.encode();
}

fn char::unicode_length(char byte) {
    if (byte & 0b10000000) == 0 {
        return 1;
    } else { if (byte & 0b11100000) == 0b11000000 {
        return 2;
    } else { if (byte & 0b11110000) == 0b11100000 {
        return 3;
    } else { if (byte & 0b11111000) == 0b11110000 {
        return 4;
    }}}}
}

fn string::utf8_decode(string input) -> rune * {
    first_byte := input[0];
    length := first_byte.unicode_length();
    self := #alloc(rune);

    if length == 1 {
        self.inner = first_byte & 0b01111111;
    } else { if length == 2 {
        self.inner = ((first_byte & 0b00011111) << 6) |
                     (input[1] & 0b00111111);
    } else { if length == 3 {
        self.inner = ((first_byte & 0b00001111) << 12) |
                     ((input[1] & 0b00111111) << 6) |
                     (input[2] & 0b00111111);
    } else { if length == 4 {
        self.inner = ((first_byte & 0b00000111) << 18) |
                     ((input[1] & 0b00111111) << 12) |
                     ((input[2] & 0b00111111) << 6) |
                     (input[3] & 0b00111111);
    }}}}

    return self;
}

fn rune::encode(rune *self) -> string {
    result := "";
    code_point := self.inner;

    if code_point <= 0x7F {
        result.push((char)code_point);
    } else { if code_point <= 0x7FF {
        result.push(0xC0 | (code_point >> 6) & 0x1F);
        result.push(0x80 | (code_point & 0x3F));
    } else { if code_point <= 0xFFFF {
        result.push(0xE0 | (code_point >> 12) & 0x0F);
        result.push(0x80 | (code_point >> 6) & 0x3F);
        result.push(0x80 | (code_point & 0x3F));
    } else { if code_point <= 0x10FFFF {
        result.push(0xF0 | ((code_point >> 18) & 0x07));
        result.push(0x80 | ((code_point >> 12) & 0x3F));
        result.push(0x80 | ((code_point >> 6) & 0x3F));
        result.push(0x80 | (code_point & 0x3F));
    }}}}

    return result;
}

fn rune::is_letter(rune *self) {
    c := self.inner;

    return (c >= 0x0041 && c <= 0x005A) ||  // A-Z
           (c >= 0x0061 && c <= 0x007A) ||  // a-z
           (c >= 0x4E00 && c <= 0x9FFF) ||  // Kanji
           (c >= 0x3040 && c <= 0x309F) ||  // Hiragana
           (c >= 0x30A0 && c <= 0x30FF);    // Katakana
}

fn rune::is_number(rune *self) -> bool {
    c := self.inner;

    // halfwidth digits (0x30 to 0x39)
    if (c >= 0x30 && c <= 0x39) {  // e.g. 0, 1, 2, ..., 9
        return true;
    }

    // fullwidth digits (0xFF10 to 0xFF19)
    if (c >= 0xFF10 && c <= 0xFF19) {  // e.g. ０, １, ２, ..., ９
        return true;
    }

    return false;
}

fn rune::is_punctuation(rune *self) {
    c := self.inner;

    if (c >= 0x21 && c <= 0x2F) ||  // e.g. !, ", #, $, %, &
       (c >= 0x3A && c <= 0x40) ||  // e.g. :, ;, <, =, >, ?
       (c >= 0x5B && c <= 0x60) ||  // e.g. [, \, ], ^, _, `
       (c >= 0x7B && c <= 0x7E) {   // e.g. {, |, }, ~
        return true;
    }

    // general punctuation (0x2000 to 0x206F)
    if (c >= 0x2000 && c <= 0x206F) {  // e.g. –, —, •
        return true;
    }

    // cjk punctuation (0x3000 to 0x303F)
    if (c >= 0x3000 && c <= 0x303F) {  // e.g. 、「」, 、, 。
        return true;
    }

    // fullwidth forms (0xFF00 to 0xFFEF)
    if (c >= 0xFF00 && c <= 0xFFEF) {  // e.g.（, ）, ！
        return true;
    }

    return false;
}
